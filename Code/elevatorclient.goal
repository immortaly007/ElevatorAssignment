init module {
	knowledge{
		% insert knowledge here, if any, or remove section.
		
		onRoute(Level) :- carPosition(Cur), moveDir(Dir), Diff is Cur - Level, (Diff<0 -> Dir = up; Dir=down).

		moveDir(Dir) :- moving(Level1, Level2), Diff is Level1 - Level2, (Diff < 0 -> Dir=up; Dir=down).
		moveDir(Dir) :- not(moving(_, _)), dir(Dir).		
		
		fs(Level, Dir, Type, Q) :- (elevatorFull, Type = f -> Penalty = 1000; Penalty = 0), carPosition(Cur), floorCount(Fl), moveDir(Dir), onRoute(Level), Q is ((Fl + 2) - abs(Cur - Level) - Penalty).
		fs(Level, Dir, Type, Q) :- (elevatorFull, Type = f -> Penalty = 1000; Penalty = 0), carPosition(Cur), floorCount(Fl), moveDir(Dir2), not(Dir = Dir2), onRoute(Level), Q is ((Fl + 1) - abs(Cur - Level) - Penalty).
		fs(Level, Dir, Type, Q) :- (elevatorFull, Type = f -> Penalty = 1000; Penalty = 0), not(onRoute(Level)), Q is 1 - Penalty.
		
		%listFS(Level, Dir, L) :- findall(elevatorQuality(Level, Q), fs(Level, Dir, Q), L).
		
		%maxFS(Level, Dir, Level) :- listFS(Level, Dir, L), maxFS(L, elevatorQuality(Level, Q)).
		
		maxFS([], levelQuality(0, 0)).
		maxFS([levelQuality(Level, Dir, Q)], levelQuality(Level, Dir, Q)). 
		maxFS([levelQuality(Level, Dir, Q) | T], levelQuality(Level, Dir, Q)) :- maxFS(T, levelQuality(Level2, Dir2, Q2)), Q >= Q2.
		maxFS([levelQuality(Level, Dir, Q) | T], levelQuality(Level2, Dir2, Q2)) :- maxFS(T, levelQuality(Level2, Dir2, Q2)), Q2 > Q.
		
		calculateFS([], []).
		calculateFS([gotoFloor(Level, Dir, Type) | T], [levelQuality(Level, Dir, Q) | T2]) :- calculateFS(T, T2), fs(Level, Dir, Type, Q).
		
		elevatorFull :- capacity(N), people(N2), N = N2.
		
		free :- not(moving(_, _)).
		
		jobsLeft(L) :-  findall(gotoFloor(Level, Dir, Type), gotoFloor(Level, Dir, Type), L).
		
		jobCount(N) :- jobsLeft(L), length(L, N).

	}
	
	beliefs{
		% The direction that will be shown to the people at the next stop.
		% This remains the intended direction of movement until there are no more
		% planned stops in that direction.
		dir(up).
		% Initially, it is unknown whether doors are open or closed.
		doorState(unknown).
		
		carPosition(0).
		
		sent(moveDir(nothing)).
		
		people(0).
	}
	
	goals{
		% insert initial goals here, if any, or remove section.
	}
	
	program {
        % insert one-time rules here, or remove section
    }
	
	actionspec{
		% The action goto(Level, Dir) moves the elevator car to floor Level. It can
		% only be performed if the elevator car is docked and not moving, i.e.,
		% atFloor(Here) holds for some Here.
		% When the elevator arrives at the requested floor, the Dir light will turn on.
		goto(Level, Dir) {
		   pre{dir(OldDir) }
		   post{dir(Dir), not(dir(OldDir)) }
		}
	}
}
	
main module{
	program{
		%%%%%% Goal Management %%%%%%
		if goal(updatePlan) then drop(updatePlan) + updatePlan.
		
		if bel( atFloor(L2), moving(L1, L2)) then delete(moving(L1, L2)).
		forall bel( atFloor(L), gotoFloor(L, Dir, e)) do delete( gotoFloor(L, Dir, e)) + updatePlan.
		if bel( atFloor(L), dir(Dir), gotoFloor(L, Dir, f), not(elevatorFull)) then delete( gotoFloor(L, Dir, f), fButtonOn(L, Dir)) + updatePlan.
		
		if bel(received(manager,goto(L, Dir))) then insert(gotoFloor(L, Dir, f)) +delete(received(manager,goto(L,Dir))) + updatePlan.

		
		%if a-goal( atFloor(Level), dir(Dir) ) then goto(Level, Dir).
		%if goal(atFloor(Level)), bel( findall(levelQuality(Level, Q), 
	}
}

module updatePlan {
	program {
		% Goto the nearest floor that the agent wants to go to.
		if bel(carPosition(Cur), moving(L1, L2), findall(gotoFloor(Level, Dir, Type), gotoFloor(Level, Dir, Type), L), calculateFS(L, FSL), maxFS(FSL, levelQuality(BestLevel, BestDir, Q))) 
			then goto(BestLevel, BestDir) + insert(moving(Cur, BestLevel)) + delete(moving(L1, L2), free).
		if bel(carPosition(Cur), findall(gotoFloor(Level, Dir, Type), gotoFloor(Level, Dir, Type), L), calculateFS(L, FSL), maxFS(FSL, levelQuality(BestLevel, BestDir, Q))) 
			then goto(BestLevel, BestDir) + insert(moving(Cur, BestLevel)).
	}
}

event module{
	program{
		%%%%% Percept Processing %%%%%
		forall bel( percept(capacity(N) )) do send(manager, capacity(N) ) + insert(capacity(N)).
		forall bel( percept(people(N) ), people(N2)) do send(manager, people(N) ) + insert(people(N)) + delete(people(N2)).
		forall bel( percept(floorCount(N) )) do send(manager, floorCount(N) )  + insert(floorCount(N)).
		forall bel( percept(carPosition(L) ), carPosition(L2), RoundedL is round(L*4) / 4, not(RoundedL = L2 )) do send(manager, carPosition(RoundedL)) + insert( carPosition(RoundedL) ) + delete(carPosition(L2) ).
		
		% The atFloor(Level) percept is received only when elevator has stopped at a floor Level.
		forall bel( percept(atFloor(Level)), not(atFloor(Level)) ) do send(manager, atFloor(Level) ) + insert( atFloor(Level) ).
		forall bel( atFloor(Level), not(percept(atFloor(Level))) ) do delete( atFloor(Level) ).
		
		% Send to the manager where the client wants to go
		forall bel( percept(eButtonOn(Level)), dir(Dir), not(gotoFloor(Level, Dir, e) )) do insert(gotoFloor(Level, Dir, e)) + adopt(updatePlan). 

		% The fButton(Level,Dir) percept indicates that the up or down (Dir) button on floor Level has been pressed.
		forall bel( fButtonOn(Level,Dir), not(percept(fButtonOn(Level,Dir))) ) do send( manager, delFButtonOn(Level, Dir) )+delete( fButtonOn(Level,Dir) ).
		forall bel( percept(fButtonOn(Level,Dir)), not(fButtonOn(Level,Dir)) ) do send( manager, fButtonOn(Level,Dir) )+insert( fButtonOn(Level,Dir) ).
		
		% The doorState percept is received only if the door state has changed.
		% So we do not need to check whether the New value is different from the Old value to avoid unnecessary updates.
		forall bel( percept(doorState(New)), doorState(Old) ) do send( manager, doorState(New) )+insert( not(doorState(Old)), doorState(New) ).		
		
		forall bel(sendDir(Dir) ) do send(manager, dir(Dir) ) + delete(sendDir(Dir) ).
		
		forall bel(moveDir(Dir1), sent(moveDir(Dir2)), not(Dir1 = Dir2) ) do send(manager, moveDir(Dir1)) + delete(sent(moveDir(Dir2))).
		
		if bel(free) then send(manager, free).
		
		
		if bel(jobCount(Count), not(sent(jobCount(Count))), sent(jobCount(Count2)), not(Count = Count2))  then send(manager, jobCount(Count)) + delete(sent(jobCount(Count2))).
		if bel(jobCount(Count), not(sent(jobCount(Count)))) then send(manager, jobCount(Count)).
	}
}

% insert additional modules, if any, here.
