init module {
	knowledge{
		% insert knowledge here, if any, or remove section.
		
		onRoute(Level) :- carPosition(Cur), moveDir(no).
		onRoute(Level) :- carPosition(Cur), moveDir(Dir), Diff is Cur - Level, (Diff<0 -> Dir = up; Dir=down).

		moveDir(Dir) :- moving(Level1, Level2), Diff is Level1 - Level2, (Diff < 0 -> Dir=up; Dir=down).
		moveDir(Dir) :- not(moving(_, _)), Dir = no.		
		
		fs(Level, Dir, Type, Q) :- Type = e, carPosition(Cur), floorCount(Fl), onRoute(Level), Q is ((Fl + 2) - abs(Cur - Level)).
		
		fs(Level, Dir, Type, Q) :- Type = f, (elevatorFull -> Penalty = 1000; Penalty = 0), carPosition(Cur), floorCount(Fl), moveDir(Dir), onRoute(Level), Q is ((Fl + 2) - abs(Cur - Level) - Penalty).
		fs(Level, Dir, Type, Q) :- Type = f, (elevatorFull -> Penalty = 1000; Penalty = 0), carPosition(Cur), floorCount(Fl), moveDir(Dir2), not(Dir = Dir2), onRoute(Level), Q is ((Fl + 0) - abs(Cur - Level) - Penalty).
		fs(Level, Dir, Type, Q) :- (elevatorFull, Type = f -> Penalty = 1000; Penalty = 0), not(onRoute(Level)), Q is 1 - Penalty.
		
		
		
		%listFS(Level, Dir, L) :- findall(elevatorQuality(Level, Q), fs(Level, Dir, Q), L).
		
		%maxFS(Level, Dir, Level) :- listFS(Level, Dir, L), maxFS(L, elevatorQuality(Level, Q)).
		
		maxFS([], levelQuality(0, 0)).
		maxFS([levelQuality(Level, Dir, Q)], levelQuality(Level, Dir, Q)). 
		maxFS([levelQuality(Level, Dir, Q) | T], levelQuality(Level, Dir, Q)) :- maxFS(T, levelQuality(Level2, Dir2, Q2)), Q >= Q2.
		maxFS([levelQuality(Level, Dir, Q) | T], levelQuality(Level2, Dir2, Q2)) :- maxFS(T, levelQuality(Level2, Dir2, Q2)), Q2 > Q.
		
		calculateFS([], []).
		calculateFS([gotoFloor(Level, Dir, Type) | T], [levelQuality(Level, Dir, Q) | T2]) :- calculateFS(T, T2), fs(Level, Dir, Type, Q).
		
		elevatorFull :- capacity(N), people(N2), N = N2.
		
		free :- not(moving(_, _)), jobsLeft(L), length(L, N),  N = 0.
		
		jobsLeft(L) :-  findall(gotoFloor(Level, Dir, Type), gotoFloor(Level, Dir, Type), L).
	}
	
	beliefs{
		% The direction that will be shown to the people at the next stop.
		% This remains the intended direction of movement until there are no more
		% planned stops in that direction.
		dir(no).
		% Initially, it is unknown whether doors are open or closed.
		doorState(unknown).
		
		carPosition(0).
		
		sent(moveDir(nothing)).
		
		people(0).
	}
	
	goals{
		% insert initial goals here, if any, or remove section.
		sendFirstUpdate.
	}
	
	program {
        % insert one-time rules here, or remove section
    }
	
	actionspec{
		% The action goto(Level, Dir) moves the elevator car to floor Level. It can
		% only be performed if the elevator car is docked and not moving, i.e.,
		% atFloor(Here) holds for some Here.
		% When the elevator arrives at the requested floor, the Dir light will turn on.
		goto(Level, Dir) {
		   pre{dir(OldDir) }
		   post{dir(Dir), not(dir(OldDir)), sendDir(Dir) }
		}
	}
}
	
main module{
	program{
		%%%%%% Goal Management %%%%%%
		if goal(sendFirstUpdate) then send(manager, jobsLeft([])) + drop(sendFirstUpdate).
		forall bel(received(manager,goto(L, Dir))) do insert(gotoFloor(L, Dir, f)) +delete(received(manager,goto(L,Dir))) + adopt(updatePlan).
		
		if bel( atFloor(L2), moving(L1, L2)) then delete(moving(L1, L2)).
		forall bel( atFloor(L), gotoFloor(L, Dir, e)) do delete( gotoFloor(L, Dir, e))  + adopt(updatePlan).
		if bel( atFloor(L), dir(Dir), gotoFloor(L, Dir, f), not(elevatorFull)) then delete( gotoFloor(L, Dir, f), fButtonOn(L, Dir))  + adopt(updatePlan).

		if bel(free, jobsLeft(L)) then send(manager, jobsLeft(L)).
		
		if goal(updatePlan) then drop(updatePlan) + updatePlan.
		%if a-goal( atFloor(Level), dir(Dir) ) then goto(Level, Dir).
		%if goal(atFloor(Level)), bel( findall(levelQuality(Level, Q), 
	}
}

module updatePlan {
	program {
		% Goto the nearest floor that the agent wants to go to.
		if bel(carPosition(Cur), moving(L1, L2), jobsLeft(L), calculateFS(L, FSL), maxFS(FSL, levelQuality(BestLevel, BestDir, Q))) 
			then goto(BestLevel, BestDir) + insert(moving(Cur, BestLevel)) + delete(moving(L1, L2)) + send(manager, jobsLeft(L)) .
		if bel(carPosition(Cur), jobsLeft(L), calculateFS(L, FSL), maxFS(FSL, levelQuality(BestLevel, BestDir, Q))) 
			then goto(BestLevel, BestDir) + insert(moving(Cur, BestLevel)) + send(manager, jobsLeft(L)) .
	}
}

event module{
	program{
		%%%%% Percept Processing %%%%%
		forall bel( percept(capacity(N) )) do send(manager, capacity(N) ) + insert(capacity(N)).
		forall bel( percept(people(N) ), people(N2), not(N = N2)) do send(manager, people(N) ) + insert(people(N)) + delete(people(N2)).
		forall bel( percept(floorCount(N) )) do send(manager, floorCount(N) )  + insert(floorCount(N)).
		forall bel( percept(carPosition(L) ), carPosition(L2), RoundedL is round(L*4) / 4, not(RoundedL = L2 )) do send(manager, carPosition(RoundedL)) + insert( carPosition(RoundedL) ) + delete(carPosition(L2) ).
		
		% The atFloor(Level) percept is received only when elevator has stopped at a floor Level.
		forall bel( percept(atFloor(Level)), not(atFloor(Level)) ) do send(manager, atFloor(Level) ) + insert( atFloor(Level) ).
		forall bel( atFloor(Level), not(percept(atFloor(Level))) ) do delete( atFloor(Level) ).
		
		% Send to the manager where the client wants to go
		forall bel( percept(eButtonOn(Level)), gotoFloor(Level, Dir2, f), not(gotoFloor(Level, Dir2, e) )) do insert(gotoFloor(Level, Dir2, e)) + adopt(updatePlan). 
		forall bel( percept(eButtonOn(Level)), dir(Dir), not(gotoFloor(Level, Dir, e) )) do insert(gotoFloor(Level, Dir, e)) + adopt(updatePlan).

		% The fButton(Level,Dir) percept indicates that the up or down (Dir) button on floor Level has been pressed.
		forall bel( fButtonOn(Level,Dir), not(percept(fButtonOn(Level,Dir))) ) do send( manager, delFButtonOn(Level, Dir) )+delete( fButtonOn(Level,Dir) ).
		forall bel( percept(fButtonOn(Level,Dir)), not(fButtonOn(Level,Dir)) ) do send( manager, fButtonOn(Level,Dir) )+insert( fButtonOn(Level,Dir) ).
		
		% The doorState percept is received only if the door state has changed.
		% So we do not need to check whether the New value is different from the Old value to avoid unnecessary updates.
		forall bel( percept(doorState(New)), doorState(Old) ) do send( manager, doorState(New) )+insert( not(doorState(Old)), doorState(New) ).		
		
		forall bel(sendDir(Dir) ) do send(manager, dir(Dir) ) + delete(sendDir(Dir) ).
		
		forall bel(moveDir(Dir1), sent(moveDir(Dir2)), not(Dir1 = Dir2) ) do send(manager, moveDir(Dir1)) + delete(sent(moveDir(Dir2))).
		
		%if bel(free) then send(manager, free).
		
		%if bel(jobsLeft(L), not (sent(jobsLeft(L))), sent(jobsLeft(L2)), not (L = L2)) then send(manager, jobsLeft(L)) + delete(sent(jobsLeft(L2))).
		%if bel(jobsLeft(L), not(sent(jobsLeft(L)))) then send(manager, jobsLeft(L)).
		
		%if bel(jobCount(Count), not(sent(jobCount(Count))), sent(jobCount(Count2)), not(Count = Count2))  then send(manager, jobCount(Count)) + delete(sent(jobCount(Count2))).
		%if bel(jobCount(Count), not(sent(jobCount(Count)))) then send(manager, jobCount(Count)).
	}
}

% insert additional modules, if any, here.
