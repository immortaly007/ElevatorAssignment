init module {
	knowledge{
		% Decides wether a certain level is on route (e.g. if we keep moving in the same direction do we get to that level. Returns true if no direction is set.
		onRoute(Level) :- carPosition(Cur), moveDir(no).
		onRoute(Level) :- carPosition(Cur), moveDir(Dir), Diff is Cur - Level, (Diff<0 -> Dir = up; Dir=down).

		% Gives the direction the car is currently moving in. If the car is stationary, Dir = no.
		moveDir(Dir) :- moving(Level1, Level2), Diff is Level1 - Level2, (Diff < 0 -> Dir=up; Dir=down).
		moveDir(Dir) :- not(moving(_, _)), Dir = no.		
		
		% fs computes the quality for each level.
		% It makes a distinction between eButton (people who are in the cart) and fButtons (people who are waiting at some floor). 
		% 
		fs(Level, Dir, Type, Q) :- Type = e, people(Pop), capacity(Cap), carPosition(Cur), floorCount(Fl), onRoute(Level), Q is ((Fl + 2) - abs(Cur - Level) + (Pop/Cap)*(0.5 * Fl)).
		
		fs(Level, Dir, Type, Q) :- Type = f, (elevatorFull -> Penalty = 1000; Penalty = 0), carPosition(Cur), floorCount(Fl), moveDir(Dir), onRoute(Level), Q is ((Fl + 2) - abs(Cur - Level) - Penalty).
		fs(Level, Dir, Type, Q) :- Type = f, (elevatorFull -> Penalty = 1000; Penalty = 0), carPosition(Cur), floorCount(Fl), moveDir(Dir2), not(Dir = Dir2), onRoute(Level), Q is ((Fl + 0) - abs(Cur - Level) - Penalty).
		fs(Level, Dir, Type, Q) :- (elevatorFull, Type = f -> Penalty = 1000; Penalty = 0), not(onRoute(Level)), Q is 1 - Penalty.
		
		maxFS([], levelQuality(0, 0)).
		maxFS([levelQuality(Level, Dir, Q)], levelQuality(Level, Dir, Q)). 
		maxFS([levelQuality(Level, Dir, Q) | T], levelQuality(Level, Dir, Q)) :- maxFS(T, levelQuality(Level2, Dir2, Q2)), Q >= Q2.
		maxFS([levelQuality(Level, Dir, Q) | T], levelQuality(Level2, Dir2, Q2)) :- maxFS(T, levelQuality(Level2, Dir2, Q2)), Q2 > Q.
		
		calculateFS([], []).
		calculateFS([gotoFloor(Level, Dir, Type) | T], [levelQuality(Level, Dir, Q) | T2]) :- calculateFS(T, T2), fs(Level, Dir, Type, Q).
		
		elevatorFull :- capacity(N), people(N2),  N = N2.
		
		free :- not(moving(_, _)), jobsLeft(L), length(L, N),  N = 0.
		
		%jobsLeft(L) :-  findall(gotoFloor(Level, Dir, Type), gotoFloor(Level, Dir, Type), L).
		
		gotoFloor(L, Dir, e) :- atFloor(L).
		gotoFloor(L, Dir, f) :- atFloor(L), dir(Dir).
		
		makeNice([], []).
		makeNice([[Level, Dir, Type]|T], [gotoFloor(Level, Dir, Type)|T2]) :- makeNice(T, T2).
	}
	
	beliefs{
		% The direction that will be shown to the people at the next stop.
		dir(no).
		
		% Initially, it is unknown whether doors are open or closed.
		doorState(unknown).
		
		% The carposition is actually unknown but we set it to 0.
		carPosition(0).
		
		% Sent
		sent(moveDir(nothing)).
		
		people(0).
	}
	
	goals{
		% insert initial goals here, if any, or remove section.
		sendFirstUpdate.
	}
	
	program {
        % insert one-time rules here, or remove section
    }
	
	actionspec{
		% The action goto(Level, Dir) moves the elevator car to floor Level. It can
		% only be performed if the elevator car is docked and not moving, i.e.,
		% atFloor(Here) holds for some Here.
		% When the elevator arrives at the requested floor, the Dir light will turn on.
		goto(Level, Dir) {
		   pre{dir(OldDir) }
		   post{dir(Dir), not(dir(OldDir)), sendDir(Dir) }
		}
	}
}
	
main module{
	program{
		%%%%%% Goal Management %%%%%%
		% Send an empty jobList to the manager, so that the manager knows that this agent is ready to accept jobs
		if goal(sendFirstUpdate) then send(manager, jobsLeft([])) + drop(sendFirstUpdate).
		
		% Adopt the auto distribution goal.
		forall bel(received(manager, gotoOnce(L, Dir)), atFloor(AtL)) do goto(L, Dir) + insert(moving(AtL, L)) + delete(received(manager, gotoOnce(L, Dir)) ).
				
		
		if bel( atFloor(L2), moving(L1, L2)) then delete(moving(L1, L2)).
		%forall bel( atFloor(L)) goal(gotoFloor(L, Dir, e)) do drop( gotoFloor(L, Dir, e)).
		%if bel( atFloor(L), dir(Dir), gotoFloor(L, Dir, f)) then delete( gotoFloor(L, Dir, f)) + send(manager, pickup(L, Dir)).
		
		if bel(atFloor(L)) then adopt(updatePlan).
		
		if goal(updatePlan) then drop(updatePlan) + updatePlan.
		
		%if a-goal( atFloor(Level), dir(Dir) ) then goto(Level, Dir).
		%if goal(atFloor(Level)), bel( findall(levelQuality(Level, Q), 
	}
}

module updatePlan {
	program {
		% Goto the nearest floor that the agent wants to go to.
		if bel(jobsLeft(L), carPosition(Cur), moving(L1, L2), calculateFS(L, FSL), maxFS(FSL, levelQuality(BestLevel, BestDir, Q))) 
			then goto(BestLevel, BestDir) + insert(moving(Cur, BestLevel)) + delete(moving(L1, L2)) + send(manager, jobsLeft(L)) .
		if bel(jobsLeft(L), carPosition(Cur), calculateFS(L, FSL), maxFS(FSL, levelQuality(BestLevel, BestDir, Q))) 
			then goto(BestLevel, BestDir) + insert(moving(Cur, BestLevel)) + send(manager, jobsLeft(L)) .
	}
}

event module{
	program{
	
		forall bel(received(manager, resetJobs)), goal(gotoFloor(Level, Dir, f)) do delete(received(manager, resetJobs)) + drop(gotoFloor(Level, Dir, f)).
		
		% If the manager send any commands, put them in the queue to execute as soon as we're close.
		forall bel(received(manager,goto(L, Dir))) do adopt(gotoFloor(L, Dir, f)) + adopt(updatePlan) + delete(received(manager,goto(L,Dir))).
		
		forall bel(jobsLeft(L)) do delete(jobsLeft(L)).
		listall L <- goal(gotoFloor(A, B, C)) do insert(jobsLeftUgly(L)).
		if bel(jobsLeftUgly(L), makeNice(L, L2)) then insert(jobsLeft(L2)) + delete(jobsLeftUgly(L)). 
		if not(goal(gotoFloor(A, B, C))) then insert(jobsLeft([])).
		
		%%%%% Percept Processing %%%%%
		forall bel( percept(capacity(N) )) do send(manager, capacity(N) ) + insert(capacity(N)).
		forall bel( percept(people(N) ), people(N2), not(N = N2)) do send(manager, people(N) ) + insert(people(N)) + delete(people(N2)).
		forall bel( percept(floorCount(N) )) do send(manager, floorCount(N) )  + insert(floorCount(N)).
		forall bel( percept(carPosition(L) ), carPosition(L2), RoundedL is round(L*4) / 4, not(RoundedL = L2 )) do send(manager, carPosition(RoundedL)) + insert( carPosition(RoundedL) ) + delete(carPosition(L2) ).
		
		% The atFloor(Level) percept is received only when elevator has st opped at a floor Level.
		forall bel( percept(atFloor(Level)), not(atFloor(Level)) ) do insert( atFloor(Level) ).
		forall bel( atFloor(Level), not(percept(atFloor(Level))) ) do delete( atFloor(Level) ).
		
		% For each eButton press adopt goal to go there
		forall bel( percept(eButtonOn(Level)) ), a-goal(gotoFloor(Level, Dir2, f), not(gotoFloor(Level, Dir2, e) )) do adopt(gotoFloor(Level, Dir2, e)) + adopt(updatePlan). 
		forall bel( percept(eButtonOn(Level)), dir(Dir)) do adopt(gotoFloor(Level, Dir, e)) + adopt(updatePlan).

		% The fButton(Level,Dir) percept indicates that the up or down (Dir) button on floor Level has been pressed.
		% If an fButton stopped being pressed, send the manager that the fButton is no longer pressed
		forall bel( fButtonOn(Level,Dir), not(percept(fButtonOn(Level,Dir))) ) do send( manager, delFButtonOn(Level, Dir) )+delete( fButtonOn(Level,Dir) ).
		% If a new fButton is pressed, send it to the manager
		forall bel( percept(fButtonOn(Level,Dir)), not(fButtonOn(Level,Dir)) ) do send( manager, fButtonOn(Level,Dir) )+insert( fButtonOn(Level,Dir) ).
		% If an fButton is no longer pressed, drop the goal to go there
		forall goal(gotoFloor(Level, Dir, f)), bel(not(percept(fButtonOn(Level,Dir)))) do drop(gotoFloor(Level, Dir, f)) + adopt(updatePlan).
		
		% The doorState percept is received only if the door state has changed.
		% So we do not need to check whether the New value is different from the Old value to avoid unnecessary updates.
		%forall bel( percept(doorState(New)), doorState(Old) ) do send( manager, doorState(New) )+insert( not(doorState(Old)), doorState(New) ).		
		
		%forall bel(sendDir(Dir) ) do send(manager, dir(Dir) ) + delete(sendDir(Dir) ).
		
		forall goal(gotoFloor(Level, Dir, e), gotoFloor(Level, Dir2, f), not(Dir = Dir2)) do drop(gotoFloor(Level, Dir, e)) + insert(gotoFloor(Level, Dir2, e)).
		
		forall bel(moveDir(Dir1), sent(moveDir(Dir2)), not(Dir1 = Dir2) ) do send(manager, moveDir(Dir1)) + delete(sent(moveDir(Dir2))).
		
		if bel(free), bel(jobsLeft(L)) then send(manager, jobsLeft(L)).
		


		
		%if bel(free) then send(manager, free).
		
		%if bel(jobsLeft(L), not (sent(jobsLeft(L))), sent(jobsLeft(L2)), not (L = L2)) then send(manager, jobsLeft(L)) + delete(sent(jobsLeft(L2))).
		%if bel(jobsLeft(L), not(sent(jobsLeft(L)))) then send(manager, jobsLeft(L)).
		
		%if bel(jobCount(Count), not(sent(jobCount(Count))), sent(jobCount(Count2)), not(Count = Count2))  then send(manager, jobCount(Count)) + delete(sent(jobCount(Count2))).
		%if bel(jobCount(Count), not(sent(jobCount(Count)))) then send(manager, jobCount(Count)).
	}
}
