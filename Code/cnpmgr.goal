init module {
	knowledge{
		onRoute(A, Level) :- carPosition(A, Cur), moveDir(A, Dir), Diff is Cur - Level, (Diff<0 -> Dir = up; Dir=down).
		
		fs(A, Level, Dir, Q) :- jobsLeft(A, L), member(gotoFloor(Level, Dir, _), L), Q is 1000.
		
		fs(A, Level, Dir, Q) :- jobsLeft(A, L), not(member(gotoFloor(Level, Dir, _), L)), agent(A), not(me(A)), carPosition(A, Cur), floorCount(A, Fl), moveDir(A, Dir), onRoute(A, Level), 
			agentBonus(A, Level, B), Q is ((Fl + 2) - abs(Cur - Level) + B).
		fs(A, Level, Dir, Q) :-  jobsLeft(A, L), not(member(gotoFloor(Level, Dir, _), L)), agent(A), not(me(A)), carPosition(A, Cur), floorCount(A, Fl), moveDir(A, Dir2), not(Dir = Dir2), onRoute(A, Level), 
			agentBonus(A, Level, B), Q is ((Fl + 1) - abs(Cur - Level) + B).
		fs(A, Level, Dir, Q) :-  jobsLeft(A, L), not(member(gotoFloor(Level, Dir, _), L)), agent(A), not(me(A)), not(onRoute(A, Level)), 
			agentBonus(A, Level, B), Q is 1 + B.
		
		agentBonus(A, Level, B) :- bonus(DefaultBonus), (free(A) -> Bonus = DefaultBonus; Bonus = 0), jobCount(A, Count), elevatorBestFloor(A, BestFloor), 
			BestFloorDistance is abs(BestFloor - Level), floorCount(A, Fl), elevatorCount(ElevatorCount),
			(elevatorFull(A) -> FullPenalty = 1000; FullPenalty = 0), 
			B is Bonus - Count*2 + (1/(BestFloorDistance+1)) * (2*Fl/ElevatorCount) - FullPenalty.
			
		elevatorFull(A) :- people(A, N), capacity(A, N). 
			
		listFS(Level, Dir, L) :- findall(elevatorQuality(A, Q), fs(A, Level, Dir, Q), L).
		
		maxFS(Level, Dir, A) :- listFS(Level, Dir, L), maxFS(L, elevatorQuality(A, Q)).
		
		maxFS([elevatorQuality(A, Q)], elevatorQuality(A, Q)). 
		maxFS([elevatorQuality(A, Q) | T], elevatorQuality(A, Q)) :- maxFS(T, elevatorQuality(A2, Q2)), Q >= Q2.
		maxFS([elevatorQuality(A, Q) | T], elevatorQuality(A2, Q2)) :- maxFS(T, elevatorQuality(A2, Q2)), Q2 > Q.
		
		jobCount(A, N) :- jobsLeft(A, L), length(L, Actual), jobsAssignedSinceUpdate(A, New), N is Actual + New.	

		free(A) :- jobCount(A, N), N = 0.
		
		elevator(A) :- agent(A), not(me(A)).
		
		agentsNotEnumerated :- elevator(A), not(elevatorNr(A, _)).
		agentsEnumerated :- not(agentsNotEnumerated).
		
		elevatorNrs([0]) :- not(elevatorNr(_, _)).
		elevatorNrs(L) :- findall(N, elevatorNr(_, N), L).
		
		elevatorBestFloor(A, Level) :- elevatorNr(A, Nr), floorCount(A, Fl), elevatorNrs(L), max_list(L, ElevatorCount), Level is round(((Fl - 1) / ElevatorCount) * Nr) - 1.
		
		notDistributedAgents :- elevator(A), not(sendElevatorToBestFloor(A)).
		distributedAgents :- not(notDistributedAgents).
		
		elevatorCount(ElevatorCount) :- elevatorNrs(L), max_list(L, ElevatorCount).
	}                                                     
	
	
	beliefs{
		bonus(100).
		
	}
	
	goals{
		pickLeadingAgent.
		agentsEnumerated.
		distributedAgents.
	}
	
	program {
		forall bel(agent(A), not(me(A))) do insert(jobsAssignedSinceUpdate(A, 0), jobsLeft(A, []), carPosition(A, 0), people(A, 0)).
    }
	
	actionspec{
	}
}
	
main module{
	program{
		if goal(pickLeadingAgent), bel( elevator(A) ) then insert(leadingAgent(A)) + drop(pickLeadingAgent).
		if a-goal(agentsEnumerated), bel( elevator(A), not(elevatorNr(A, _)), elevatorNrs(L), max_list(L, Max), ToAssign is Max + 1 ) then insert(elevatorNr(A, ToAssign)).
		forall a-goal(distributedAgents), bel( elevatorBestFloor(A, Level), not(sendElevatorToBestFloor(A)) ) do send(A, gotoOnce(Level, up)) + insert(sendElevatorToBestFloor(A)).
		
		
		if a-goal(sendElevator(Level,Dir)),bel(maxFS(Level,Dir,A), jobsAssignedSinceUpdate(A, N), N2 is N + 1)
			then send(A, goto(Level,Dir)) + insert(jobsAssignedSinceUpdate(A, N2)) + delete(jobsAssignedSinceUpdate(A, N)) + drop(sendElevator(Level,Dir)).
		
		forall bel(received(A, pickup(Level, Dir)), fButtonOn(Level, Dir)) do adopt(sendElevator(Level, Dir)) + delete(received(A, pickup(Level, Dir))).	
			
		if bel(fButtonOn(Level, Dir), free(A)), not(a-goal(sendElevator(Level, Dir))), bel(findall(elevatorQuality(A2, Q), (free(A2), fs(A2, Level, Dir, Q)), L), maxFS(L, elevatorQuality(A, Q))) then send(A, goto(Level, Dir)).
	}
}

 event module{
	 program{		 
		% Receive some constants and current states
		forall bel( received(A,capacity(N) )) do delete( received(A,capacity(N)) ) + insert( capacity(A,N) ).
		forall bel( received(A,floorCount(N) )) do delete(received(A,floorCount(N) )) + insert(floorCount(A,N) ).
		
		forall bel( received(A,people(N)), people(A, N2)) do delete( people(A, N2),received(A,people(N)) ) + insert ( people(A, N) ).
		
		forall bel( received(A,carPosition(L) ), carPosition(A,L2), not(L = L2)) do delete(received(A,carPosition(L)), carPosition(A,L2)) + insert(carPosition(A,L) ).
		
	    % fButtonOn processing (independent of elevator/client)
	    forall bel( received(A, fButtonOn(Level, Dir)), leadingAgent(A) ) do delete( received(A, fButtonOn(Level, Dir)) ) + insert( fButtonOn(Level, Dir) ) + adopt(sendElevator(Level,Dir)).
		forall bel( received(A, fButtonOn(Level, Dir))) do delete( received(A, fButtonOn(Level, Dir)) ).
		forall bel( received(A, delFButtonOn(Level, Dir)) ) do delete( fButtonOn(Level, Dir), received(A, delFButtonOn(Level, Dir)) ).		
		
		% Process directions
		forall bel( received(A, moveDir(Dir)), moveDir(A,OldDir) ) do delete(received(A, moveDir(Dir) ),moveDir(A,OldDir) ) + insert(moveDir(A, Dir) ).
		
		% Update jobsLeft
		%if bel(received(A, jobsLeft(L)), not (jobsLeft(A, _)) ) then insert(jobsLeft(A, L)) + delete(received(A, jobsLeft(L))).
		forall bel(received(A, jobsLeft(L)), jobsLeft(A, L2), jobsAssignedSinceUpdate(A, N), not(N = 0), not(L = L2)) do delete(jobsLeft(A, L2), received(A, jobsLeft(L)), jobsAssignedSinceUpdate(A, N)) + insert(jobsLeft(A, L), jobsAssignedSinceUpdate(A, 0)).
        forall bel(received(A, jobsLeft(L)), jobsLeft(A, L2), jobsAssignedSinceUpdate(A, N), N = 0, not(L = L2)) do delete(jobsLeft(A, L2), received(A, jobsLeft(L))) + insert(jobsLeft(A, L)).
		forall bel(received(A, jobsLeft(L)), jobsLeft(A, L), jobsAssignedSinceUpdate(A, N), not(N = 0)) do delete(received(A, jobsLeft(L)), jobsAssignedSinceUpdate(A, N)) + insert(jobsAssignedSinceUpdate(A, 0)).
        forall bel(received(A, jobsLeft(L)), jobsLeft(A, L), jobsAssignedSinceUpdate(A, N), N = 0) do delete(received(A, jobsLeft(L))).
		
	}
}