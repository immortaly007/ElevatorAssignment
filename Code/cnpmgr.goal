init module {
	knowledge{
		% insert knowledge here, if any, or remove section.
	
		%elevatorAtFloor(Level, Dir) :- elevatorAtFloor(A, Level), elevatorDir(A, Dir).
		
		%elevatorAtFloor(A, Level, Dir):- elevatorAtFloor(A, Level), elevatorDir(A, Dir).
		%elevatorAtFloor(any, Level, Dir) :- elevatorAtFloor(A, Level), elevatorDir(A, Dir).
		
		%readyToSend(A, Level, Level2) :- free(A), elevatorAtFloor(A, Level2), not(Level = Level2).
		
	    %moveDir(A, Dir) :- moving(A, Level1, Level2), Diff is Level1 - Level2, (Diff < 0 -> Dir=up; Dir=down).
		%moveDir(A, Dir) :- not(moving(A, _, _)), elevatorDir(A, Dir).

		onRoute(A, Level) :- carPosition(A, Cur), moveDir(A, Dir), Diff is Cur - Level, (Diff<0 -> Dir = up; Dir=down).
		
		fs(A, Level, Dir, Q) :- jobsLeft(A, L), member(gotoFloor(Level, Dir, _), L), Q is 1000.
		
		fs(A, Level, Dir, Q) :- jobsLeft(A, L), not(member(gotoFloor(Level, Dir, _), L)), agent(A), not(me(A)), carPosition(A, Cur), floorCount(A, Fl), moveDir(A, Dir), onRoute(A, Level), 
			agentBonus(A, B), Q is ((Fl + 2) - abs(Cur - Level) + B).
		fs(A, Level, Dir, Q) :-  jobsLeft(A, L), not(member(gotoFloor(Level, Dir, _), L)), agent(A), not(me(A)), carPosition(A, Cur), floorCount(A, Fl), moveDir(A, Dir2), not(Dir = Dir2), onRoute(A, Level), 
			agentBonus(A, B), Q is ((Fl + 1) - abs(Cur - Level) + B).
		fs(A, Level, Dir, Q) :-  jobsLeft(A, L), not(member(gotoFloor(Level, Dir, _), L)), agent(A), not(me(A)), not(onRoute(A, Level)), 
			agentBonus(A, B), Q is 1 + B.
		
		agentBonus(A, B) :- bonus(DefaultBonus), (free(A) -> Bonus = DefaultBonus; Bonus = 0), jobCount(A, Count), B is Bonus - Count*2.
			
		listFS(Level, Dir, L) :- findall(elevatorQuality(A, Q), fs(A, Level, Dir, Q), L).
		
		maxFS(Level, Dir, A) :- listFS(Level, Dir, L), maxFS(L, elevatorQuality(A, Q)).
		
		maxFS([elevatorQuality(A, Q)], elevatorQuality(A, Q)). 
		maxFS([elevatorQuality(A, Q) | T], elevatorQuality(A, Q)) :- maxFS(T, elevatorQuality(A2, Q2)), Q >= Q2.
		maxFS([elevatorQuality(A, Q) | T], elevatorQuality(A2, Q2)) :- maxFS(T, elevatorQuality(A2, Q2)), Q2 > Q.
		
		jobCount(A, N) :- jobsLeft(A, L), length(L, N).	

		free(A) :- jobsLeft(A, L), length(L, N), N = 0.
	}                                                                                                         
	
	
	beliefs{
		% insert initial beliefs here, if any, or remove section.
		bonus(3).
		
	}
	
	goals{
		% insert initial goals here, if any, or remove section.
		pickLeadingAgent.
	}
	
	program {
        % insert one-time rules here, or remove section
    }
	
	actionspec{
		% insert global action specification here, if any, or remove section.
	}
}
	
main module{
	program{
		%if a-goal(elevatorAtFloor(A, Level, Dir)), bel(readyToSend(A, Level, OldLevel)) then
			%send( A, goto(Level, Dir) ) + delete(free(A), elevatorAtFloor(A, OldLevel)) + insert(moving(A, OldLevel, Level)).
		%if a-goal(elevatorAtFloor(any, Level, Dir)), bel(not(moving(_, OldLevel, Level)), readyToSend(A, Level, OldLevel) ) then 
			%send( A, goto(Level, Dir) ) + delete(free(A), elevatorAtFloor(A, OldLevel)) + insert(moving(A, OldLevel, Level)).
			
		if goal(pickLeadingAgent), bel(agent(A), not(me(A)) ) then insert(leadingAgent(A)) + drop(pickLeadingAgent).	
		if a-goal(sendElevator(Level,Dir)),bel(maxFS(Level,Dir,A)) then send(A, goto(Level,Dir))+drop(sendElevator(Level,Dir)) + delete(free(A)).
	}
}

 event module{
	 program{		 
		% Receive some constants and current states
		forall bel( received(A,capacity(N) )) do insert( capacity(A,N) ) + delete( received(A,capacity(N)) ) .
		forall bel( received(A,floorCount(N) )) do insert(floorCount(A,N) ) + delete(received(A,floorCount(N) )).
		
		forall bel( received(A,people(N)), not(people(A, _))) do insert( people(A,N) )+delete(received(A,people(N))).
		forall bel( received(A,people(N)), people(A, N2)) do insert ( people(A, N) ) + delete( people(A, N2),received(A,people(N)) ).
		
		forall bel( received(A,carPosition(L) ), not(carPosition(A,_))) do insert(carPosition(A,L) ) + delete(received(A, carPosition(L))).
		forall bel( received(A,carPosition(L) ), carPosition(A,L2)) do insert(carPosition(A,L) ) + delete(carPosition(A,L2),received(A,carPosition(L))).
		
 		% Receive and save the location of the clients to the believe base
		%forall bel( received(A, atFloor(Level)), moving(A, Level2, Level) ) do insert( elevatorAtFloor(A, Level)) + delete( received(A, atFloor(Level)), moving(A, Level2, Level) ).
		%forall bel( received(A, atFloor(Level)), not(moving(A, Level2, Level)) ) do insert( elevatorAtFloor(A, Level)) + delete(received(A, atFloor(Level)) ).

		% Receive and save what button the client pressed (eButtonPressed)
		%forall bel( received(A,  eButtonOn(Level, Dir)) ) do insert( clientWantsToGo(A, Level, Dir) ) + delete( received(A, eButtonOn(Level, Dir)) ).
		
	    % fButtonOn processing (independent of elevator/client)
	    forall bel( received(A, fButtonOn(Level, Dir)), leadingAgent(A) ) do insert( fButtonOn(Level, Dir) ) + delete( received(A, fButtonOn(Level, Dir)) ) + adopt(sendElevator(Level,Dir)).
		forall bel( received(A, fButtonOn(Level, Dir))) do delete( received(A, fButtonOn(Level, Dir)) ).
		forall bel( received(A, delFButtonOn(Level, Dir)) ) do delete( fButtonOn(Level, Dir), received(A, delFButtonOn(Level, Dir)) ).
		
		% Process the doorstate for each client
		forall bel( received(A, doorState(New)), elevatorDoorState(A, Old), not(Old = New) ) do insert ( elevatorDoorState(A, New) ) + delete( elevatorDoorState(A, Old), received(A, doorState(New)) ).
		forall bel( received(A, doorState(New)), not(elevatorDoorState(A, Old)) ) do insert ( elevatorDoorState(A, New) ) + delete( received(A, doorState(New)) ).
		
		% Process free agents
		%forall bel( received(A, free) ) do insert(free(A)) + delete(received(A, free) ).
		
		% Process directions
		forall bel( received(A, moveDir(Dir)), moveDir(A,OldDir) ) do insert(moveDir(A, Dir) ) + delete(received(A, dir(Dir) ),moveDir(A,OldDir) ).
		
		% Update jobsLeft
		forall bel(received(A, jobsLeft(L)), not (jobsLeft(A, _)) ) do insert(jobsLeft(A, L)) + delete(received(A, jobsLeft(L))).
		forall bel(received(A, jobsLeft(L)), jobsLeft(A, L2)) do insert(jobsLeft(A, L)) + delete(jobsLeft(A, L2), received(A, jobsLeft(L))).
		
		%forall bel(received(A, jobCount(Count)), not(jobCount(A, _))) do insert(jobCount(A, Count)) + delete(received(A, jobCount(Count))).
		%forall bel(received(A, jobCount(Count)), jobCount(A, Count2)) do insert(jobCount(A, Count)) + delete(jobCount(A, Count2), received(A, jobCount(Count))).
		
		
		%forall bel( received(A, moveDir(Dir)), elevatorDir(A, Dir2), not(Dir = Dir2) ) do insert(elevatorDir(A, Dir) ) + delete(received(A, dir(Dir) ), elevatorDir(A, Dir2) ).
		
		%forall bel( elevatorAtFloor(A, Level), clientWantsToGo(A, Level, Dir), elevatorDoorState(A, opened) ) do delete(clientWantsToGo(A, Level, Dir)) .
		
		
		%%%%%%%%%%%% Goal Management %%%%%%%%%%%
		%forall bel( fButtonOn(Level, Dir), fs(A, Level, Dir, Q) ) do adopt( elevatorAtFloor(any, Level, Dir)) .
		%forall bel( clientWantsToGo(A, Level, Dir) ) do adopt( elevatorAtFloor(A, Level, Dir)) + delete(clientWantsToGo(A, Level, Dir)).
		
		%%%%%%%%%%%% Sending Order %%%%%%%%%%%
		%forall bel()
		
	}
}

% insert additional modules, if any, here.
