\documentclass[a4paper,10pt,twocolumn]{article}

\usepackage[utf8]{inputenc}
\usepackage{amsmath}
%\usepackage[margin=1in]{geometry}

%opening
\title{The \textsc{Goal} Multi-agent Elevator Assignment}
\author{Bas Dado \& Canran Gou}

\begin{document}

\maketitle

\section{Introduction}
This project concerns a building with a number of elevators. The goal of the project is to implement an algorithm that optimizes the average total time needed to move people to the floors they want to go. We use a modified version of the nearest car algorithm for the agents as the basic rule. The clients (elevators) do some percept work and sends this information to a manager. This manager will apply the algorithm to decide which client should get the job and assign to it.
The clients themselves choose in which order they want to handle their assigned tasks.

\section{The MAS design}
The MAS consists of two types of agents: the so-called manager that is responsible for dividing the tasks, and the clients that execute these tasks. The manager is not connected to the environment and therefore communication is used to keep it up to date with the current state of the world. The manager uses this information  to calculate the ``quality'' for each of the clients to take handle service a floor on which people are waiting. The agent with the highest quality is assigned to that task. 

Clients decide the order in which they execute their assigned tasks. To do this, clients use an equation similar to the one the manager uses the calculate the best agent, but they use it to calculate the best floor to visit next. Every time new information is received, the quality for all floors is re-evaluated and the elevator will go to the floor with the highest quality. This way it chooses the optimal path within it's current job list at all times.

The communication happens in two directions: clients send their current job list and percepts to the manager, and the manager sends tasks to it's clients. Communication does not follow the contract net protocol for optimization reasons. The manager now has all information about the environments and all elevators and uses this information to calculate what would be the bids of each agent in the contract net protocol. The advantage of this is that the manager can use information about some client to influence the bid of another client. For example: the number of elevators is used and bonuses are added for the least busy clients. Of course one could add these bonuses after the bids are calculated within the clients themselves, but then the manager would still need to have all information about the world. It also would require some wait time for all bids to come in, which will decrease the decision making speed. In our opinion the advantages of our simple communication outweigh those of the contract net protocol.

The quality is calculated using a modified version of the nearest car algorithm. The basic rule for the nearest car algorithm is to assign the elevator with the highest quality to a certain task. The quality $FS$ is calculated in the following way:
\begin{itemize}
 \item If an elevator is moving towards a call, and the call is in the same direction, we get:
\begin{equation}
 FS = (N + 2) - d
\end{equation}
 Where $N$ is one less than the number of floors in the building, and $d$ is the distance in floors between the elevator and the passenger call.
 \item For a call in the opposite direction, we have:
\begin{equation}
 FS = (N + 1) - d.
\end{equation}
 \item In the end if the elevator is moving away from the point of call: 
 \begin{equation}
  FS = 1.
 \end{equation}
\end{itemize}
Nearest car was modified using bonuses and penalties to perform better in certain cases. The details of this will be explained in the manager and client descriptions.


\subsection{Manager}
The manager takes environmental information such as the \texttt{carPosition}, \texttt{moveDirection} and current jobs for each elevator, and the status of all \texttt{fButtons}. When a new task appears (an \texttt{fButton} is pressed), it uses the information it has about the environment to determine which client is the best choice for this specific task. It does this by calculating the $FS$ and adding some bonus $B$. This bonus is determined by applying each of the following rules:
\begin{itemize}
 \item If the elevator has no jobs it is currently working on, the \texttt{defaultBonus} is added. The defaultBonus is relatively big so that free elevators get chosen if they are available. This helps make sure that the elevators are always working, which should improve the performance.
 
 \item The number of jobs an elevator currently has assigned to it (and has not finished yet) is multiplied by $2$ and subtracted. This is done to control the workload for each elevator and make sure that the tasks are divided evenly over the elevators.
 
 \item If the elevator is full and can therefore not carry any more people, a penalty of $1000$ is subtracted from the bonus. This is a relatively huge number compared to the value of $FS$ and the rest of the bonuses. Therefore the task will always go to an elevator that is not full if such an elevator is available.
 
 \item For each elevator, a so-called \emph{best floor} is decided using:
 \begin{equation}
  F_\text{best} (e) = \frac{F_\text{total} - 1}{E_\text{total}} \times i(e) - 1
 \end{equation}
 In which $F_\text{total}$ is the total number of floors, $E_\text{total}$ is the total number of elevators and $i(e)$ is the index of the current elevator.
 The distance to this optimal floor

\end{itemize}




In the final algorithm some elements of the static sectoring algorithm are used as well. This was done because a lot of floors require service pretty quickly after the environment is started. This means that floors require service before the elevators are divided evenly over the building. The nearest car algorithm will then keep the elevators close together and assign the tasks sort of randomly.

In the knowledge base of manager, we implement the modified nearest car algorithm. We receive the job list of every client in event module and use it to update the $FS$ values as seeing if any current goals are member of job list. The basic rule for this equation is:



With this equation we calculate $FS$ value for each agent for each floor and direction, then we may use them to decide which agent shall be chosen when there's a new task.

Besides, we modified the algorithm by adding a bonus-penalty system to improve the performance. For example, if there's a free elevator, we want to make use of them so give it a bonus to make it work again. Full elevators, of course, got a high penalty to prevent it stopping by. To control the workload balance of elevators, we take the current task number as a factor for penalty to assign jobs more evenly.

In the main module, we choose the leading-agent, to which the manager will listen about \texttt{fButton} and \texttt{deleteFButton} events. We choose it to avoid multiple inserting and deleting operations of \texttt{fButton}. Then the manager will check goal base to pick a goal and find the agent with best $FS$ value of the goal, then send goto command to it. There are two situations we care in the end, one is when a elevator leave after finishing picking up people, it will check if the respective \texttt{fButton} is still on(there are still people there), and send another elevator to it if so, and finally we'll check if there are free elevators and assign jobs to keep them working.

\subsection{Clients}
Clients need to handle several tasks. First of all they need to percepts and process the environment. This is done, as expected in \textsc{goal}, in the event module. The advantage of using the event module for percepts is that every statement in the event module gets executed in each cycle of the agent. This is exactly what we want for percepts like \texttt{fButton}, \texttt{eButton}, \texttt{carPosition}, \texttt{people} and \texttt{atFloor}. Note that only if the percept changes, this is send to the manager. For \texttt{fButtons}, when 

\section{Answers to the questions posed}

\section{Discussion on the usefulness of logic in MAS}



\end{document}
